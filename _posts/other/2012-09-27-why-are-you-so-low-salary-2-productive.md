---
layout: post
title: 你为什么薪水那么低(二)之 生产力
keywords: 薪水, 效率, 方法
category : other
tags : [方法]
---

在上一篇文章中提到，升薪的关键在于『[你可以做别人做不了的事](http://justjavac.com/other/2012/09/21/why-are-you-so-low-salary.html)』。

程序员，就是整天与机器打交道的那群人。 
在计算机并不普及的年代，这样的描述毫无疑问。

然而，这些年来，得益于计算机成本的不断下降，软件使用门槛的不断降低，
如今，昔日昂贵而又神秘不可莫测电脑，已经成了随处可见、人人能用的办公器材。
一句话：**人机交互，不再是程序员的专利**。

大家都可以用电脑干活，只不过，程序员用电脑写程序，其他人用电脑干其它事。 

结果，普通人抱怨的问题，程序员也在抱怨：电脑不够聪明，不够智能，效率太低…… 
 
可是，电脑真的进化到了对程序员和普通用户“一视同仁”的地步吗？ 
 
我不由得想起，上个世纪80年代，温伯格在《技术领导之路》中提出的疑问： 

>  （开办技术领导力学习班）也让我们产生怀疑，技术在当今社会扮演了重要的角色，我们的学习班，是否赋予了某些人太多的力量？ 
 
细细想来，当年，IT技术那么高深，只有少数人能够接触，因而程序员“理所当然”地借助了IT的东风，具有超常的力量。
可是如今呢？与常人无异的程序员（或者说，IT 技术人员），他们身上让人担心的“太大的”力量，
到底是被淘汰了，还是没有发挥出来？ 
 
对这个问题，不同的人或许有不同的看法。不过，读过 The Productive Programmer（中文版《[卓有成效的程序员](http://t.cn/zWRXVoq)》）的人，
多半会选择后一个答案——程序员的实力还没有发挥出来。 
 
The Productive Programmer 是一本奇特的书，它的 Productive（也就是“生产力”），
与新的语言、新的框架、新的系统完全无关，而是另辟蹊径：它只是提醒读者，作为程序员，
你与普通用户是不同的：**其它人只是简单地“启动”程序，而你完全可以动用自己的专业知识，
“驱使/调度”那些程序**。

这样的机会，普通用户想不到，也不愿意抓住，但是抓住它们，你的生产率就会成倍上升。
所以，这本书叫做 The Productive Programmer，而不是 The Productive Computer-User。 
 
薄薄的一本书（英文版224页，中文版215页），共分16章，兼顾概念和实践两个方面，
既介绍了加速、专注、自动化等等提高生产率的“先进”思维观念
（譬如**多用键盘少用鼠标**，**消除干扰集中精力**），
也给出了在设计、分析、构造、元编程、多语言编程等等多种任务中贯彻前述思想的若干实例
（譬如 **用全面测试保证质量**，**选用最省事的方式/语言完成任务**），可以说是“麻雀虽小，五脏俱全”了。 
 
不过，看完整本书，我最深刻的印象还是贯彻全书的思想。
说白了，就是**尽量让机器做机器该做的事情，让程序和程序打交道，
发挥程序员在这方面的先天优势——他人眼中的普通工具，是程序员手里的有利武器**。 

不信，你可以想想，虽然如今人机交互的难度已经大大下降，然而程序终究是程序，程序跟人打交道，
与程序跟程序打交道，效率差的不是一星半点： 

<ul>
  <li>不用宏，你可能需要一次又一次地重复选择、修改、保存； </li>
  <li>不用脚本，你可能需要一次又一次地点击、配置、等待； </li>
  <li>不用自动化测试，你可能需要一遍又一遍地运行、调试； </li>
  <li>不用管道，你可能需要一次又一次地生成、删除中间文件； </li>
  <li>…… </li>
</ul>
 
The Productive Programmer则会“教导”你： 

<ul>
  <li>多用宏吧，启动它，你就可以迅速完成大量重复的工作； </li>
  <li>多用脚本吧，你可以提高运行的效率，避免变数和误差； </li>
  <li>多用自动化测试吧，你可以迅速定位问题，保证质量； </li>
  <li>多用管道吧，这样多个程序就可以“无缝结合”成一条生产线； </li>
  <li>…… </li>
 </ul>
 
没错，学习宏、脚本、自动化测试、管道（Shell），不是“容易”的事情。
但别忘了，**身为技术人员，了解技术，学习技术，运用技术，正是你的职业，
你的优势，也是你的责任，你的生产力（所谓productive）所在**。

随便举个例子吧，在本书中文版的第196页有这么一段话： 
 
>  ……在我刚才提到的例子中，开发人员用了1小时58分建立正确的语法，然后用了不足两分钟运行。
> 在一些未曾培训过的人眼里，他的大多数时间都没有效率（这就是为什么他们反对使用正则表达式的原因），
> 但最后，他节省的是几天的时间！…… 
 
我还要补充的是，解决好这样的问题，“现在”能节省几天的时间，将来，更可以节省无穷无尽的时间！
就我的开发经历来说，平时多注重这样的细节，做些 “没效率”的事情，
积累起来，就可以节省大量的时间和精力——至少至少，
你不会抱怨，自己终日被一大堆“简单重复劳动”所困扰。 
 
类似的例子，在书中随处可见，譬如作者讲到

> 几乎每个 *nix 用户，都会有自己的 shell alias

真是于我心有戚戚焉：我自己积累了一大堆 alias，喜欢用 grep –color 把要找的内容标成高亮，
也喜欢在统计脚本里用不同的颜色标注不同的状态……
**在 Shell 下干活，更加简单、利索，一目了然，这种流畅和效率，也可算专属于程序员的宝贵财富**。 
 
当然，也有读者会觉得很烦：作者几乎讲一个很小的例子，几乎都要强调一遍：
“**简单重复劳动是低效的（程序员不应该这么干）**”。

不过，我丝毫没有觉得罗嗦，反而因此喜欢上这本一个下午就能看完的“轻量级”小书：
阅读它，你并不需要太多的期望，权当一次愉快的思维体操吧——你会发现，
专属于自己的高效率，就来自书中提到的点点滴滴。