---
layout: post
title: 代码之谜 - 运算符
keywords: 代码之谜
category : codepuzzle
tags : [代码之谜]
---

从最简单的运算符加号(+)说起，加号(+)是个二元运算符——也就是说，**加号只把两个数联接起来，从来不把第三个或者更多的联接起来**。

因此，“1加2加3” 在计算机中被表述为：

	(1 + 2) + 3      // a

或者

	1 + (2 + 3)      // b

虽然我们通常写做 `1 + 2 + 3`，但是并不意味这它和我们数学中的 1+2+3 是等价的。

那么数学中的 1+2+3 到底表示的是 a 呢，还是 b 呢？

如果计算机的求值是左结合的，那么此表达式等价于第一种a；
如果是右结合的，那么此表达式等价于第二种b。

`1 + 2 + 3` 简单的理解就是 “把1、2、3加在一起”，
确实，在我们接触到的数学里面，就是把三个数加起来。
但是在编程语言中，却不仅仅这样。

就像前面说的那样，+号无法操作三个或者更多的数，参与加法运算的只能是两个数。

顺便说一句，正号、负号是一元运算符，虽然它们和二元运算符加、减用相同的符号，
但是他们却是不同的，所以不要想当然的认为 +4 就等价于 0+4，其实它们不是等价的，
**+4 是一个整数，但是 0+4 是一个加法表达式，这个表达式的求值结果正好是 +4**。

在 java 中，我们可以写 `short a = -4`，但是当我们写 `short a = 0 - 4` 时则产生一个警告。

还有一个其它例子，同样是关于 short 的，

	short b = 1;
	short b = b + 4;   // 警告
	short b += 4;      // 无警告

那么 `1 + 2 + 3` 是如何运算的呢？
在冯诺依曼体系架构的编程语言中，
这里有一个副作用——我习惯称那些“计算机的运算过程与程序员的大脑思考过程不一样时，则称为副作用”（虽然书本里面没有这么写过，但我一向这么认为），
**本来你以为会是这样，结果计算机偏偏就不是这样做的，我称他为副作用。**

如果看过前面的『[语句与表达式](http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html)』，这可以这么理解：

1 + 2 是一个表达式，它的返回值是 3。
这个表达式的返回值再参加到另一个表达式中 3 + 3，最后得出结果6。

我们用语句（Statement）来改写这段代码：

	// 计算 1 + 2 + 3
	var a = 1 + 2;
	var b = b + 3;

如果我们用 lisp 语言对这个表达式求值，则没有副作用。

	(+ (+ 1 2) 3)

如果你还没有懂，或者这个例子太有特殊性，那么我们换一个

	5 > 4 > 3

在数学中，这个算式的值为 true。当我们用C语言来写这段代码，它返回的确实 false。

原因和上面的一样，大于号(>)是二元运算，它无法直接比较三个数，5 > 4 返回的结果是 true，
当用 true 和 3 比较时，true 被转换称 1，也就是 `1 > 3`，最终的结果自然就是 false 了。

总之，回归到了『[语句与表达式](http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html)』篇的那个观点：在编程语言中 **每个表达式都有一个值**。

编程语言中的运算符和数学中的运算器虽然一样，但是它们却并不等同。
**当你写程序时，要写给人看； 当你调试程序时，要学会用计算机的方式思考代码的含义。**

我习惯于把运算符理解为函数，比如 2 + 5 其实就是 add(2, 5) 或者 2.add(5)。
难道我会偷偷的告诉你 “其实很多语言都是这么做的”。
