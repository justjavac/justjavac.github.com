---
layout: post
title: 代码之谜 - 开篇/前言/序
tagline: 其实，你不懂代码
description: 其实，你不懂代码
keywords: 代码之谜
category : codepuzzle
tags : [代码之谜]
---

答应了群里的兄弟们要更新博客，结果回家又是洗衣服做饭的，转眼已经10点多了。

趁洗衣机正在转的功夫，打开 Evernote 找到了以前的几段 javascript 代码，本着人性本贱(咳，咳，该死的输入法，更正「人性本荐」)的精神，
给大家共享一下，不定期更新，算是我「代码之谜」系列的开篇吧。

我喜欢读一些让人震惊的书，比如『GEB』，比如『从一到无穷大』，读完后张大嘴巴，「哇噻，太不可思议了，太令我震惊了」。
本系列博客的目的之一就是让每个阅读过的人在思维方式上有所改变，变得更理性，更加会思考，会学习。

本系列说来话长，从10年开始构思，当时写在 evernote 里面，名字叫『理性，像数学家一样思考』，废话少说，言归正传，贴代码吧

第一段代码: 

    function foo1(a){
        return a + '01';
    }

    foo1(01);

第二段代码: 

    function foo2(a){
        return a + '010';
    }

    foo2(010);
    
第三段代码: (注: 这不是 javascript 的问题，而且所有语言的问题，归根结底是 IEEE 标准中二进制浮点运算的问题，关于浮点数的详细问题请阅读 [代码之谜 - 浮点数]()，「为什么没有链接呢，呵呵，因为我还没有写，正在整理中」。)
    
    console.log(0.2 + 0.4);
    
第四段代码就相对来说简单多了: 参考我一些发布的这篇<a href="http://justjavac.com/javascript/2012/05/24/can-you-explain-why-10.html" href="_blank">为什么 ++[[]][+[]]+[+[]] = 10?</a>。

    [4,[3,2]][1][0];     // 3

-------------------------------------

2012年9月25日 22时25分 更新

还是忍不住，睡前想唠叨几句。

也许很多人第一次接触编程时，对 `i = i + 1` 都感到百撕不得骑姐(咳，我就说了嘛，必须得换一个输入法了，更正「百思不得其解」)。

> “i加上1怎么可能和i相等呢？”

后来慢慢知道了，不，确切的说，是慢慢地接受了，接受了=是赋值（前提是你学的不是pascal，我的入门语言就是它），因为**你可能根本没有思考，只是被动接受**。

再后来，我们学了 if， 开始写分支代码：

    if (a >3) { 
        // do something        
    }
    
    if (a < 5) {
        // do  something
    }

但是当我们写出 `if (3 < a < 5)` 时，居然报错了，又是百撕不… 后来被教导了，这么写是错的，应该 `if (a>3 && a<5)`。
于是我们又开始接受了，认为这么写是理所当然的，而且以后的代码都是这么写的。

直到有一天，你看了 python 的入门手册，尼玛，居然逆天的出现了 'if 3 < a < 5:'，当时绝对又震惊了，“怎么可以这么写？”。
难道你忘了，N年前你就是这么写的，而且当时你不也认为 `3 < a < 5` 是理所当然的吗（任何一个高中生都会同意这种写法），
为什么你现在又开始觉得 `3 < a < 5` 是种逆天写法呢，因为你在这几年的编程生涯中，已经被动接受了太多太多的东西，而且使你根本就不曾思考过，
这也是我写「代码之谜」系列的初衷。

当你被告知了，在编程中=是赋值的意思(其实他们没有告诉你，只是大部分语言这样，还有很多语言不是这样，比如pascal中:=是赋值，比如basic/VB中=即是赋值也是判断)，
但是=如果不是相等的话，那肯定有表示相等的，对，就是==，或者===。

不管是==还是=，「相等」到底是什么意思呢？=或者==或者===，即使以后会出现====，到底和数学的「相等」有多少出入呢？

知道我们遇到了传说中的NaN（很多人认为NaN既然表示Not A Number，那么他就是语言定义的一个东东，根本不存在，这是错误的，NaN是在IEEE浮点数规范中明确定义的，包括本系列后面
后提到的+0和-0问题），它不等于任何值，而且，它居然不等于它自己。

一个数居然不**等于**它自己，其实确切的说，是 NaN == NaN 居然返回 false， 甚至 NaN === NaN 也返回 false。是 NaN 的问题，还是==或者===的问题，抑或这根本就是**相等**这个概念的问题。

在集合论中，相等的三要素，不管是==还是===，都无法满足，所以说，===根本就不是相等（如果你读过数学的「群伦」就更明白了）。

相等（等价）的三要素

<ol>
    <li>自反省: A等于A</li>
    <li>对称性: 如果A等于B，那么B等于A</li>
    <li>传递性: 如果A等于B，而且B等于C，那么A等于C</li>
</ol>

当我们看到这几条定理时，我们从来没有怀疑过。
脱离了数学，我们进入了编程领域，当我们遇到了NaN，
我们知道了，在IEEE的数字表示规范里面，「自反省」是不被满足的，那么传递性和对称性呢？ 如果你找到了反例，可以留言。

也许你说，相等/等于/全等/等价这些比较特殊，其它的应该都会满足吧。
我只能告诉你（说通俗一点），以前的所有定理、公理都只适用于一个领域，当它进入另一个领域我们就不能把它当作理所当然的，也许它没有问题，比如 1+2=3，但也许这只是一个巧合，
上面我就提到了 0.2+0.4 就不等于 0.6。

计算机和现实最大的不同（也是问题的根源）就是，世界是连续的，而计算机是非连续的，是离散的。
以前我们学校图书馆有很多「计算机数学」或者「离散数学」之类的书，我现在都不明白，里面写的那些数学，是设计计算机的工程师读呢，还是使用计算机的程序员读呢？里面的内容简直就是大杂烩嘛。
什么是离散数学呢？我的理解，不连续的数学都是离散数学。比如量子论里面用到的数学，就是离散数学。

其它算数定律或者定义有不满足的吗？

再举一例，上小学刚学乘法运算的时候老师就告诉我们，3x4就是4个3相加，下面这个例子再次颠覆你的想法。

    console.log(0.1 * 10);
    console.log(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1);

写完睡觉，如果大家有什么更好的例子，欢迎补充。